import math
import json
import pandas as pd
import requests
import time
import vaex
import datatable as dt
from SHE import *
from point_in_rectangle import raw_test_in
import networkx as nx
import matplotlib.pyplot as plt
from threading import Thread
import ahttp


tree = []  # 定位位置的四叉树层序遍历序列
tree_len = 5  # 代表四叉树的深度


def judge(x1, y1, x2, y2, xx, yy):  # x1,y1表示整个地图的左上上边界，x2，y2代表左下边界，xx,yy是待定位的点
    x_core = x1 / 2 + x2 / 2
    y_core = y1 / 2 + y2 / 2
    global tree
    global tree_len
    if judge_part(x1, y1, x_core, y_core, xx, yy):
        tree.append(1)
        if len(tree) < tree_len:
            judge(x1, y1, x_core, y_core, xx, yy)
    if judge_part(x_core, y_core, x2, y2, xx, yy):
        tree.append(4)
        if len(tree) < tree_len:
            judge(x_core, y_core, x2, y2, xx, yy)
    if judge_part(x1, y_core, x_core, y2, xx, yy):
        tree.append(3)
        if len(tree) < tree_len:
            judge(x1, y_core, x_core, y2, xx, yy)
    if judge_part(x_core, y1, x2, y_core, xx, yy):
        tree.append(2)
        if len(tree) < tree_len:
            judge(x_core, y1, x2, y_core, xx, yy)
    if len(tree) == tree_len:
        return tree


def judge_part(upx, upy, downx, downy, x, y):
    if (upx - x) * (downx - x) <= 0 and (upy - y) * (downy - y) <= 0:
        return True
    else:
        return False


k0 = 1024
k1 = 40
k2 = 100
n = 9546781931902272913828923724295801735314808738336117082299855267526370781255410204449406183189400394191553500504449780688226003981177767136688893176578431780322420126401247136429165105301768530585293216949048184660695178056521666063185594615709133221269883743509535638513583807607257049234822319285931079665127506948312293265462750992730487096731909922004955846964412738284005178524252365786602967132981374441626648735927147993313988069522138931741286006285375781327263105630906425730759283730995117116175980110578844530483675184106347643567976063814425010197997214633010035560584865048895967251500913096080836509883
length = 1124127490067959807263446365663
p = 103208146936017409001064853981771185455864998286468294292021651567093072755391006690797243062245227974110161616783290449963036069502455840116375500599809354378065508136232575810480600455008819848432899485314223940884758720245320373749115428478542050852778707911799037417936981398197252130697237545750626590533
q = 92500274593832986367397251378162856898838275239456223267003750596901351153941833991986120538983877035861510032124601559966888180086822596869763089693497173235432383986470751400008096226782421678729605536602796869447709469839623881733446440439628853239420308159705321567723006363118922973092807357378500861951


def send_to_decrypt(d):
    html = ahttp.post("http://127.0.0.1:8080/api",
                         data=json.dumps({"data": d})).run()
    return json.loads(html.text)["res"]


def place_send_to_decrypt(d):
    html = requests.post("http://127.0.0.1:8080/placeapi",
                         data=json.dumps({"data": d}))
    return json.loads(html.text)["res"]


def search_id(ssid):
    data = dt.fread(r"static\data\t100_dbtrack.txt").to_pandas()
    # data = pd.read_csv("static/data/dbtrack.txt")
    start_time = time.time()
    illdata = data[(data["ssid"] == ssid)]
    healthdata = data[data["ssid"] != ssid]
    print(illdata.shape[0])
    print(healthdata.shape[0])
    foundid = []
    for i in range(illdata.shape[0]):
        tmy = illdata.iat[i, 0]
        area = [int(con) for con in (illdata.iat[i, 5].split(";"))]
        x, y = int(illdata.iat[i, 2]), int(illdata.iat[i, 3])
        othertrack = healthdata[(tmy <= healthdata["t"]) &
                                (healthdata["t"] <= (tmy + 1800)) &
                                (healthdata["ssid"].isin(
                              list(set(healthdata["ssid"]) - set(foundid))))
                                & (healthdata["treeid"].isin(area))
                            ]
        print(othertrack.shape[0])
        for j in range(othertrack.shape[0]):
            dis = [(int(othertrack.iat[j, 2])**2 + x**2,
                        int(othertrack.iat[j, 2]) * x +
                         int(othertrack.iat[j, 2]) * x + 30000),
                   (int(othertrack.iat[j, 3]) ** 2 + y ** 2,
                   int(othertrack.iat[j, 3]) * y +
                    int(othertrack.iat[j, 3]) * y + 30000)]
            if send_to_decrypt(dis):
                nx, ny = int(othertrack.iat[j, 2]), int(othertrack.iat[j, 3])
                dd = [(ny ** 2 + y ** 2, ny * y + ny * y + 22500),
                      (int(math.sqrt(3)*1000) * nx + 1000*ny,
                       int(math.sqrt(3)*1000) * x + 300000 + 1000*y),
                      (int(1000*math.sqrt(3)) * x + 1000*y,
                       int(1000*math.sqrt(3)) * nx + 1000*ny + 300000)]
                if send_to_decrypt(dd):
                    foundid.append(othertrack.iat[j, 1])
    end_time = time.time()
    print(end_time-start_time)
    return foundid


def vaex_new_search_id(ssid):
    data = vaex.open("static/data/dbtrack.hdf5")
    start_time = time.time()
    # data = pd.read_csv("static/data/dbtrack.txt")
    with open("static/data/list.json", "r") as f:
        treedata = f.read()
    treedata = json.loads(treedata)
    illdata = data[(data["ssid"] == ssid)]
    healthdata = data[data["ssid"] != ssid]
    print(illdata.shape[0])
    print(healthdata.shape[0])
    foundid = []
    for i in range(illdata.shape[0]):
        othertrack = healthdata.copy()
        tmy = illdata[i][0]
        # area = [int(con) for con in (illdata[i, 5].split(";"))]
        x, y = int(illdata[i][2]), int(illdata[i][3])

        data1 = []
        data2 = []
        data3 = []
        for ertreeid in illdata[i][5].split(";"):
            try:
                data1 += treedata[str(tmy)][ertreeid]
            except:
                pass
            try:
                data2 += treedata[str(int(tmy) + 900)][ertreeid]
            except:
                pass
            try:
                data3 += treedata[str(int(tmy) + 1800)][ertreeid]
            except:
                pass
        data1 = list(set(data1) - set(foundid))
        data2 = list(set(data2) - set(foundid))
        data3 = list(set(data3) - set(foundid))
        print(data1)
        print(data2)
        print(data3)
        filterdata = data1+data2+data3
        othertrack = othertrack[((othertrack.t == int(tmy))
                                 & (othertrack.ssid.isin(filterdata)))]
        # | ((healthdata["t"] == int(tmy)+900) &
        #             (healthdata["ssid"] in (data2))) |((healthdata["t"] == int(tmy)+1800) &
        #             (healthdata["ssid"] in (data3))))
        length1 = othertrack.shape[0]
        print(othertrack)
        for j in range(othertrack.shape[0]):
            dis = [(int(othertrack[j][2]) ** 2 + x ** 2,
                    int(othertrack[j][2]) * x +
                    int(othertrack[j][2]) * x + 30000),
                   (int(othertrack[j][3]) ** 2 + y ** 2,
                    int(othertrack[j][3]) * y +
                    int(othertrack[j][3]) * y + 30000)]
            if send_to_decrypt(dis):
                nx, ny = int(othertrack[j][2]), int(
                    othertrack[j][3])
                dd = [(ny ** 2 + y ** 2, ny * y + ny * y + 22500),
                      (int(math.sqrt(3) * 1000) * nx + 1000 * ny,
                       int(math.sqrt(3) * 1000) * x + 300000 + 1000 * y),
                      (int(1000 * math.sqrt(3)) * x + 1000 * y,
                       int(1000 * math.sqrt(3)) * nx + 1000 * ny + 300000)]
                if send_to_decrypt(dd):
                    foundid.append(othertrack[j][1])
    end_time = time.time()
    print(end_time - start_time)
    return foundid


def search_relationships(ssids):
    data = dt.fread(r"static\data\t100_dbtrack.txt").to_pandas()
    start_time = time.time()
    ssids = ssids.split(";")
    foundrela = []
    for i in range(len(ssids)-1):
        adata = data[data.id == ssids[i]]
        bdata = data[data.id.isin(ssids[i+1:])]
        for j in range(adata.shape[0]):
            cdata = bdata[(bdata.t >= int(adata.iat[j, 0])-900) &
                          (bdata.t <= int(adata.iat[j, 0])+900)]
            for k in range(cdata.shape[0]):
                cal = [(int(adata.iat[j, 2], 16)**2+int(adata.iat[j, 3], 16)**2 +
                        int(cdata.iat[k, 2], 16)**2+int(cdata.iat[k, 3], 16)**2,
                        2*int(adata.iat[j, 2], 16)*int(cdata.iat[k, 2], 16) +
                        2*int(adata.iat[j, 3], 16)*int(cdata.iat[k, 3], 16) +
                        30000)]
                if send_to_decrypt(cal):
                    foundrela.append((adata.iat[j, 1],
                                      cdata.iat[k, 1]))
    # G = nx.Graph()
    # G.add_nodes_from(ssids)
    # G.add_edges_from(foundrela)
    # nx.draw(G, with_labels=True, node_color="red")
    # plt.show()
    print("foundidrela", foundrela)
    newresult = []
    for i in range(len(foundrela)):
        newresult = newresult + list(foundrela[i])
    print("未关联人员：", set(ssids) - set(newresult))
    print("用时: ", time.time()-start_time)
    return {"res": foundrela}


def pandas_new_search_id(ssid):
    # data = pd.read_csv("static/data/dbtrack.txt")
    # eplus3 = 428385558655070592061554442958003409345952463246963311929367878954035490592348858214704635019604332335508207301524071370686424019894870082993447247570437708330251459761319508353379408862290512314584181105134539344518766246665237778209739321493542622941497339937169320972709659672793813004721357111224656262332794338875051058935735124314728816688736851632290966196428380314715774895939975965361185022949585681280615025423134566163556895078793262739530197113970599921561081906182943272678914172918151755205365782024690956575015916211019738777092231775238374347295892425475852375238207773574381741175352808596305280729208388455334023675112332613818645459822325426844068431337033790437872409205814832086523680354616386306892656494111328985564789122143710186865096432619118516613033026397370361143599149052700736860309529445685672203000571329126154759560228501984495984366488706964223057470899417319965213359322113208122251058429536441797833768334178322483179648910160984208139467166885312994473384133274178065431621907930825917045471842415428493129551251821795163643345609111097879437524730017981829685489808486256201235127883345611534671671010874594666163420481253926726137260550590755492874610828357325215038677542980124435922654859653
    # esub3 = 595484351399914455089427885820121532631221539946532599716810258812173201596603501715798274292790610447420824821546832695757372993531011859130127925483376779730555148663204301004632449497197310692103694517960354554161287058817410016470573647154444661770277521938193178240459863405270682088897443970722661327209888419750253929233810024665432959983635078903334423362194394337106336098435389401101746125791013044215093949392969089624713565302484438322328761668795814601130058629363691494206715756965352376642441919515538227815786693589575076804289848094657099659407189705107871456872496323098066172168308047510567622912098597475638311643380310732498758124195208825353583677052842117179731337390490035046488361336294475103916762426326573136383009285544327018644860039183251197175656886688259573342987237090258905404775840040705888475874703846147508452565682574471322238188220101039971933344802974959662209726699480762432454285990197352964608291482985683188553022767365483967662804845781945259368912109550624840009678298228915433783970627701259362298444028894019549449213810553137493657893824264631956910297055764457477174251304552107154634032233929677911595852101281854816485166168819358065301012283738268743316994837788062878995688834223

    data = dt.fread(r"static\data\t100_dbtrack.txt").to_pandas()
    start_time = time.time()
    # with open("static/data/t100_list.json", "r") as f:
    #     treedata = f.read()
    # treedata = json.loads(treedata)
    illdata = data[data["id"].isin(ssid.split(";"))]
    healthdata = data[~data["id"].isin(ssid.split(";"))]
    foundid = ssid.split(";")
    task = []
    tid = []
    tdd = []
    for i in range(illdata.shape[0]):
        # othertrack = healthdata.copy()
        tmy = illdata.iat[i, 0]
        x, y = int(illdata.iat[i, 2], 16), int(illdata.iat[i, 3], 16)
        # data1 = []
        # data2 = []
        # data3 = []
        # for ertreeid in illdata.iat[i, 5].split(";"):
        #     try:
        #         data1 += treedata[str(tmy)][ertreeid]
        #     except:
        #         pass
        #     try:
        #         data2 += treedata[str(int(tmy) + 900)][ertreeid]
        #     except:
        #         pass
        #     try:
        #         data3 += treedata[str(int(tmy) + 1800)][ertreeid]
        #     except:
        #         pass
        # data1 = list(set(data1) - set(foundid))
        # data2 = list(set(data2) - set(foundid))
        # data3 = list(set(data3) - set(foundid))
        # othertrack = othertrack[
        #     ((othertrack.t == int(tmy)) & (othertrack["id"].isin(data1)))
        #     |((othertrack["t"] == int(tmy) + 900)&(othertrack["id"].isin(data2)))
        #     | ((othertrack["t"] == int(tmy) + 1800)&(othertrack["id"].isin(data3)))]
        farea = [int(a) for a in illdata.iat[i, 5].split(";")]
        othertrack = healthdata[(healthdata.t <= (int(tmy)+900)) &
                                (healthdata.t >= (int(tmy)-900)) &
                                (~healthdata.id.isin(foundid)) &
                                (healthdata.treeid.isin(farea))
                                ]
        # print(othertrack)
        for j in range(othertrack.shape[0]):
            # 矩形——乘形式  18.40886s
            dis = [(int(othertrack.iat[j, 2], 16) ** 2 + x ** 2,
                    int(othertrack.iat[j, 2], 16) * x +
                    int(othertrack.iat[j, 2], 16) * x + 30000),
                   (int(othertrack.iat[j, 3], 16) ** 2 + y ** 2,
                    int(othertrack.iat[j, 3], 16) * y +
                    int(othertrack.iat[j, 3], 16) * y + 30000)]

            # 取代接口解密作测试，时间为6.17s，所以，时间可能是浪费在接口解密了
            # dd = [decrypt(p, length, d[0]) - decrypt(p, length, d[1])
            # for d in dis]
            # if max(dd) <= 0:
            #     foundid.append(othertrack.iat[j, 1])

            # 矩形——加减形式 17.60843515396118
            # dis = [(x+esub3, int(othertrack.iat[j, 2], 16)),
            #        (int(othertrack.iat[j, 2], 16), x+eplus3),
            #        (y + esub3, int(othertrack.iat[j, 3], 16)),
            #        (int(othertrack.iat[j, 3], 16), y + eplus3)
            #        ]
            # 圆形判断
            # dis = [(int(othertrack.iat[j, 2], 16) ** 2 + x ** 2 +
            #        int(othertrack.iat[j, 3], 16) ** 2 + y ** 2,
            #        int(othertrack.iat[j, 2], 16) * x * 2 +
            #        int(othertrack.iat[j, 3], 16) * y * 2 + 30000)]
            # 接口解密
            # if send_to_decrypt(dis):
            #     foundid.append(othertrack.iat[j, 1])
            # 测试ahttp, 8.64s
            task.append(ahttp.post("http://127.0.0.1:8080/api",
                         data=json.dumps({"data": dis})))
            tid.append(othertrack.iat[j, 1])

            #     nx, ny = int(othertrack.iat[j, 2], 16), int(
            #                  othertrack.iat[j, 3], 16)
            #     dd = [(ny ** 2 + y ** 2, ny * y + ny * y + 22500),
            #           (int(math.sqrt(3) * 1000) * nx + 1000 * ny,
            #            int(math.sqrt(3) * 1000) * x + 300000 + 1000 * y),
            #           (int(1000 * math.sqrt(3)) * x + 1000 * y,
            #            int(1000 * math.sqrt(3)) * nx + 1000 * ny + 300000)]
            #     if send_to_decrypt(dd):
            #         foundid.append(othertrack.iat[j, 1])
    # stime = time.time()
    res = ahttp.run(task, pool=500)
    for r in range(len(res)):
        if json.loads(res[r].text)["res"]:
            foundid.append(tid[r])
    end_time = time.time()
    # print(end_time-stime)
    print(end_time - start_time)
    return foundid


def place_search(t0, t1, treeid, area=None):
    if area is None:
        area = []
    rawdata = dt.fread(r"static\data\t100_dbtrack.txt").to_pandas()
    start_time = time.time()
    all_user = list(set(rawdata["id"]))
    foundid = []
    while t0 <= t1:
        data = rawdata[(rawdata["t"] == t0) & (~rawdata["id"].isin(foundid)) &
                       (rawdata["treeid"].isin(treeid))]
        # print(data.shape[0])
        for j in range(data.shape[0]):
            point = [int(data.iat[j, 2], 16), int(data.iat[j, 3], 16)]
            verify = []
            for i in range(len(area) - 1):
                verify.append(((point[0] + area[i][0]) *
                               (point[1] + area[i + 1][1]),
                               (point[0] + area[i + 1][0]) *
                               (point[1] + area[i][1])))
            if place_send_to_decrypt(verify):
                foundid.append(data.iat[j, 1])
        t0 += 900
    end_time = time.time()
    print(end_time-start_time)
    return list(set(foundid))


if __name__ == "__main__":
    """
    # 大范围
    # area = [[12020000, 4029000], [11967000, 4056139],
    #         [12010000, 4080000], [12060000, 4077777],
    #         [12060000, 4060000], [12020000, 4029000]]
    # 全范围
    # area = [[11966845, 4028802], [11966845, 4096139],
    #         [12078164, 4096139], [12078164, 4028802],
    #         [11966845, 4028802]]
    tree = []
    faketree = [469, 697, 905, 817, 206, 659, 798, 942, 187, 622, 337, 799,
                100, 465, 455, 956, 86, 765, 1023, 431, 19, 827, 301, 536, 70,
                158, 374, 756, 976, 554, 470, 588, 270, 388, 941, 73, 165, 488,
                232, 627, 518, 480, 45, 844, 389, 763, 240, 287, 108, 603, 833,
                660, 583, 929, 863, 803, 142, 555, 720, 62, 176, 544, 837, 485,
                418, 729, 998, 993, 51, 472, 873, 384, 239, 5, 475, 861, 843,
                474, 259, 825, 918, 201, 415, 563, 944, 607, 264, 500, 227,
                520, 186, 39, 574, 328, 8, 434, 791, 832, 537, 797, 527, 774,
                244, 370, 40, 107, 752, 693, 909, 894, 394, 410, 263, 306, 396,
                858, 1003, 18, 188, 675, 860, 135, 426, 883, 816, 255, 210,
                505, 571, 277, 699, 320, 71, 911, 74, 486, 351, 535, 140, 327,
                404, 824, 354, 892, 674, 153, 549, 940, 340, 288, 27, 766, 907,
                722, 522, 900, 295, 189, 151, 175, 539, 377, 854, 362, 332,
                886, 511, 162, 967, 110, 739, 468, 792, 23, 1008, 67, 128, 95,
                303, 487, 969, 438, 995, 261, 471, 262, 99, 621, 34, 247, 92,
                692, 573, 492, 375, 582, 196, 568, 672, 61, 182, 545, 954, 594,
                961, 606, 805, 1010, 702, 829, 243, 59, 510, 341, 400, 965,
                533, 414, 246, 11, 913, 743, 365, 193, 602, 393, 234, 543, 771,
                448, 79, 416, 109, 651, 800, 831, 617, 213, 452, 112, 777, 87,
                429, 121, 183, 379, 348, 856, 297, 710, 369, 367, 955, 601,
                634, 595, 530, 345, 169, 662, 253, 684, 671, 828, 314, 229,
                191, 453, 948, 950, 738, 3, 132, 289, 717, 317, 381, 106, 63,
                447, 709, 55, 593, 339, 733, 558, 696, 872, 137, 506, 711, 203,
                498, 600, 780, 359, 397, 184, 770, 517, 553, 131, 524, 888,
                260, 566, 749, 548, 97, 148, 811, 938, 174, 508, 391, 221, 790,
                57, 939, 705, 788, 507, 647, 299, 479, 64, 849, 737, 467, 926,
                272, 585, 430, 960, 219, 570, 880, 155, 813, 930, 760, 312,
                815, 433, 725, 687, 482, 747, 124, 640, 43, 177, 564, 123, 230,
                127, 807, 784, 613, 915, 937, 897, 238, 119, 1004, 546, 41,
                616, 719, 390, 54, 267, 789, 946, 512, 992, 273, 1015, 979,
                209, 559, 504, 130, 576, 501, 624, 515, 439, 154, 891, 681,
                502, 283, 688, 669, 98, 222, 964, 28, 623, 266, 313, 552, 605,
                308, 778, 618, 925, 1019, 226, 550, 936, 989, 378, 959, 256, 2,
                963, 994, 252, 641, 56, 477, 44, 363, 178, 366, 376, 53, 361,
                17, 757, 368, 205, 237, 584, 349, 364, 962, 122, 604, 293, 407,
                432, 884, 494, 781, 1020, 493, 149, 190, 516, 35, 572, 409, 65,
                235, 231, 982, 286, 88, 890, 104, 526, 324, 701, 291, 307, 528,
                881, 629, 208, 685, 896, 521, 882, 565, 931, 425, 741, 276,
                577, 609, 315, 347, 138, 392, 645, 458, 612, 852, 980, 562,
                597, 945, 152, 451, 436, 801, 424, 1022, 1006, 249, 372, 1021,
                678, 168, 1017, 735, 497, 463, 665, 489, 49, 636, 265, 1002,
                668, 50, 503, 42, 204, 401, 398, 216, 386, 802, 637, 714, 251,
                614, 330, 323, 281, 343, 167, 838, 847, 449, 473, 779, 814,
                412, 300, 842, 316, 444, 768, 919, 846, 898, 639, 984, 869,
                245, 850, 285, 899, 236, 338, 423, 567, 751, 557, 68, 783, 157,
                935, 865, 22, 957, 677, 150, 615, 1, 309, 269, 223, 851, 114,
                101, 586, 395, 80, 912, 835, 81, 352, 280, 655, 732, 727, 282,
                195, 1001, 643, 133, 745, 927, 274, 953, 764, 459, 921, 290,
                906, 31, 908, 356, 541, 619, 16, 48, 445, 598, 373, 862, 26,
                514, 592, 319, 910, 523, 77, 818, 331, 812, 648, 83, 867, 476,
                405, 143, 20, 194, 278, 580, 333, 848, 578, 37, 302, 509, 311,
                385, 810, 579, 730, 632, 417, 839, 670, 656, 170, 454, 60, 611,
                866, 357, 819, 758, 625, 334, 809, 496, 821, 654, 754, 804,
                199, 120, 718, 160, 304, 76, 630, 1024, 657, 551, 587, 91, 795,
                271, 695, 268, 978, 734, 241, 973, 491, 853, 346, 440, 435,
                532, 513, 7, 441, 761, 403, 728, 495, 25, 38, 904, 667, 1000,
                968, 708, 82, 834, 296, 599, 258, 85, 310, 864, 715, 991, 985,
                420, 879, 1005, 707, 242, 93, 589, 680, 1007, 181, 159, 129,
                380, 30, 644, 649, 569, 248, 664, 988, 903, 855, 466, 575, 762,
                192, 958, 786, 987, 785, 14, 683, 214, 700, 895, 355, 974, 298,
                179, 525, 782, 419, 689, 556, 724, 4, 163, 254, 990, 225, 47,
                529, 542, 29, 10, 951, 103, 443, 126, 679, 830, 145, 822, 996,
                113, 228, 111, 344, 750, 917, 115, 294, 1014, 744, 437, 875,
                172, 841, 336, 36, 117, 966, 211, 943, 859, 24, 360, 975, 706,
                628, 682, 156, 326, 89, 94, 924, 874, 631, 977, 46, 171, 691,
                776, 350, 12, 1016, 499, 118, 638, 902, 292, 652, 534, 690,
                836, 200, 450, 726, 383, 704, 650, 321, 371, 934, 1013, 6, 999,
                446, 769, 986, 642, 75, 146, 406, 793, 775, 318, 772, 663, 949,
                257, 676, 72, 116, 212, 399, 9, 971, 180, 773, 877, 102, 723,
                547, 250, 166, 673, 820, 887, 202, 413, 483, 217, 731, 279, 33,
                460, 90, 519, 755, 408, 590, 561, 224, 703, 845, 387, 284, 653,
                428, 713, 538, 531, 620, 207, 658, 325, 421, 742, 635, 66, 484,
                753, 871, 220, 136, 748, 58, 490, 411, 78, 464, 1009, 633, 342,
                134, 746, 456, 173, 868, 305, 233, 806, 808, 402, 889, 823,
                164, 626, 933, 736, 335, 105, 686, 740, 358, 666, 144, 952,
                885, 422, 52, 560, 716, 197, 462, 901, 96, 610, 914, 21, 878,
                275, 794, 139, 646, 141, 767, 932, 125, 1018, 329, 382, 461,
                840, 983, 928, 581, 661, 198, 32, 796, 1012, 694, 591, 478, 69,
                870, 876, 923, 947, 893, 997, 981, 608, 759, 712, 922, 970,
                698, 161, 15, 916, 427, 972, 13, 787, 721, 215, 1011, 826, 147,
                442, 920, 185, 481, 84, 322, 218, 457, 540, 353, 857, 596]

    tree_len = 5
    x1, y1, x2, y2 = 11966845, 4096139, 12078164, 4028802
    area = [[12000000, 4030000], [12060000, 4030000],
            [12060000, 4060000], [12000000, 4030000],
            [12000000, 4030000]]

    treeid = []
    treex = [x1 + 111319/64 + (111319/32)*i for i in range(32)]
    treey = [y2 + 67337/64 + (67337 / 32) * i for i in range(32)]
    for x in treex:
        for y in treey:
            if raw_test_in(area, [x, y]):
                r = judge(x1, y1, x2, y2, x, y)
                tree = []
                treeid.append(faketree[(r[0]-1)*256+(r[1]-1)*64+(r[2]-1)*16
                                       + (r[3]-1)*4 + (r[4] - 1)])
    print(treeid)
    # 只是加入了各个节点
    for a in area:
        r = judge(x1, y1, x2, y2, a[0], a[1])
        tree = []
        treeid.append(faketree[(r[0]-1)*256+(r[1]-1)*64+(r[2]-1)*16 + (r[3]-1)*4 + (r[4] - 1)])
    print(len(treeid))

    for i in range(len(area)):
        area[i][0] = encrypt(p, length, k0, k2, n, -area[i][0])
        area[i][1] = encrypt(p, length, k0, k2, n, -area[i][1])
    result = place_search(1648742400, 1648742400+900*2, treeid, area)
    # result = place_search(1648742400, 1648742400 + 900 * 2, area)
    print(result)
"""
    result = pandas_new_search_id("zydzyd")
    print(result)

    # result = search_relationships("zydzyd;c11810604b87f5b4;e550870a533827f6;"
    #                               "ab4f3eef246e30ba;8bded3198dbce76a;"
    #                               "da9a6adb943be301;a657b10797029446")
    # print(result)
    # 测试速度
    # dis = [(87003211191047869668188639278322759781206577281957772594206838539012949531199613545689567836000311203138209718637403536965847837063353526464375209733683881599723462917049081830875905526208822304210611518819130970805565151712183021682122411947804610791507801741612194907219208871541211151654717178957340396527067748235569030479900475186265460835417934042841239384024851237140113668334855215492446487383717744969107625992490335776342743157076166001878668407801003991734445282074136712260009584065421762652238395433452454989033603692856470979943558542809902064654635529710118971046570626069101011404358805263232481157372837049774831754241279488326641537355515802958709303038958223226103801816953895582557310107456870870885428825820255998183028090299862319190374593838116062862139155673150449900315406915006674055966165252508334214701171427947189220796804031638884494614357391708663411725047892332324460049641849329757850215077800427864089676987035941912257832884080013164996996257242379496391950422434401780266577892717960821254121870417556250096032167539125150021998488892458790676002856121623213781324535454722753807191303920072834870009561094367881035623041687630555488415410553194848088201932786388062006843192308733424646877967618, 34184577506621655282666253828303966965534259318008080148179586824077131195224643021085712886658640799724679939899238996690072268802066692859254622622199270926853416507634672702423651873853619856160901618036632057750485176926897997495025888225310143179472017149958439426919850691341410566214805309054245850691751781091451758407380810536133537384337184821991636380371397154483163314889745676246472140358334776692207698884986043876727100283112862930919281448834294812290209562885567847098540292004913331793784480665752558981039813699226723193975224052794928777310893950930473836295609026366917970596125986946470043485307409381082989062798187709448123759298753371793628925954623199759500483879112432020815495200344302020513768132999209777382690435241425670024330311410149365112903468180400792674477829443853204211252745247463139057604256880691824995795912362930019937192113847856892047923261563494511090722845647123158672319395819133456475280765145844031417022851332861818065162690469386356848106096433245852438401706866149603267265860622275921008235236432932214308853569710143783446143729657247288662790141177541072428982801857747236717378672956193571904343655793671310290125211956905592158365866817236024322724530240729071010770047282), (19399708257527270917320236697874125698456243565025737331337165813831282889889788395731196127933302229107553474406375308998100828733151827880557883132138286318158045762613387886691110088821540716205232682666978578315879063606921802178951986506109287377749282296054733424613751924250550015660598634460069611146341333793029631554990871123899391118536439583403049548912693943565557782134110127873934132771988973296226869098584907269249943327182519395593782618414694131010099062118224026092621774189902274488812748835436000799786695316123562769962465519309795205833010833511801913454131463653585470025557797147297226191769487358553262586207912884396503571200221027731650344880562322888698995203904354324232650169240874942974857845336691924070166628431281016688221188121455591005522107875766791339834242692806925098814387856558323559933231421434254923763630536489533034459578999222735447810042403181026044616525876315224980636214047938602133034402966752578434008017985009324207159396310004055724093926871083397824254463414802538507027095934947854701651683567932604102017601073971184366528020904118282343920360930713522332614107183389094185801567281757028645824390321145260769110475132086831202656643763334510637070538272952002723121763873, 1730040884276637663481537137383664713277419762942604912566968165065516593073995954393734966012090193884893355503066907913216028255449502081724051121063490305942566388124680543908123198262250064778648799143148400648580124246042813087813597009956510337396830734774542472325555944472858739186813834511548935735824521308726622848379296520590333514725946608524040222165015309728455520134942346869951948581457666690923014236145332321454839723150936524536645456201462790573114533627430955568953812587245348016391169182321102779534135784026525973265759066861145447694539144595355466299558819781823126994632285459155022599326915987252995844942894622416916524416610893799337002760890805565860335323379317386260012962761571109600571970932705362151427099763852427970550100204088428562376236270795960064641414133391800700633156534313648409872839368760953521213752668255438838399487992909042762029555323860632799884630754305649717188172271439831868424957323755838135756227903735277033464415985672268513876596362508932515413450657929782503021270687316969387724811232508228825122101454011870914813480028697535059434315210984090937720728636931363921387435163663882880638050086559696758885203688810394965278436242633252980671246665987456854422218248)]
    # start_time = time.time()
    # # session = requests.Session()
    # task = []
    # for i in range(1000):
    #     # session.get("http://127.0.0.1:8080")
    #     task.append(ahttp.get("http://127.0.0.1:8080/"))
    #     # send_to_decrypt(dis)
    # res = ahttp.run(task, pool=1000)
    # end_time = time.time()
    # print(end_time - start_time)
